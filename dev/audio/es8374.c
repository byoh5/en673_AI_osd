#include "dev.h"

#ifdef __AUDIO__
#ifdef __AUD_ES8374__
#include "dev_inline.h"
#include "es8374.h"

//-----------------------------------------------------------------------------
// I2C control function
//-----------------------------------------------------------------------------
#define I2C_CHECK	I2c2_Check
#define I2C_WRITE	I2c2_Write
#define I2C_READ	I2c2_Read

typedef struct {
	char volume;	// -127~48, not use(-128, 49~127)
}es8374_state;

static es8374_state es8374_info = {
	.volume = 0x00,
};

#if 1
static BYTE es8374_reg_defaults[][2] = {
	{0x00, 0x3F},	// Soft reset
	//msleep(50);	// must need some delay time
	{0x00, 0x03},	// un reset, to normal operation

	{0x02, 0x08},	// 
	{0x01, 0xFF},	// 
	{0x04, 0x20},	// 
	{0x05, 0x14},	// 
	{0x06, 0x06},	// Internal DACLRCK divider[11:8]
	{0x07, 0x08},	// Internal DACLRCK divider[7:0]	// $CMT-hjlee-170725 - ori(0x00) => hjlee(0x08)

	{0x0F, 0x9D},	// 

	{0x6F, 0xA0},	// 
	{0x72, 0x41},	// 
	{0x09, 0x01},	// 
	{0x0C, 0x0B},	// 
	{0x0D, 0xDA},	// 
	{0x0E, 0xCC},	// 
	{0x0A, 0x3A},	// 
	{0x0B, 0x07},	// 
	{0x09, 0x41},	// 
	{0x24, 0x08},	// 
	{0x36, 0x40},	// 

	{0x12, 0x30},	// 
	{0x13, 0x20},	// 

	{0x21, 0x50},
	{0x22, 0x33},
	{0x21, 0x14},
	{0x10, 0x2C},	// $CMT-hjlee-170725 - ori(0x0C) => hjlee(0x2C)
	{0x11, 0x0C},
	{0x00, 0x80},	// 
	{0x14, 0x8A},	// 
	{0x15, 0x40},	// 

	{0x1A, 0xA0},	// Mono out / def:0x18
//	{0x17, 0xA8},	// new
	{0x1B, 0x9B},	// Mono out / def:0x19 => 0x9B º¼·ı ÃÖ´ë?
	{0x1C, 0x90},	// 0x80 => 0x90
	{0x1D, 0x08},
	{0x1F, 0x00},
	{0x1E, 0x00},	// 0xA0:SPK output, 0x00:disable

	{0x25, 0x00},
	{0x26, 0xCF},	// MIC ALC Control 0xCF(on) or 0x0F(off)
	{0x27, 0x04},
	{0x28, 0xA0},
	{0x29, 0x12},
	{0x2A, 0x06},
	{0x2B, 0x78},

	{0x38, 0x00},
	{0x37, 0x30},	// 0x08 => 0x00
	{0x6D, 0x60},

	{0x71, 0x05},
	{0x73, 0x70},    

	{0x36, 0x40},
//	msleep(50);		// must need some delay time
//	{0x36, 0x00},
//	msleep(100);	// must need some delay time
	{0x37, 0x00},	// dac set

	{0x07, 0x00},	// Internal DACLRCK divider[7:0]	// $CMT-hjlee-170725 - new

	{0x45, 0x06},
	{0x46, 0x56},
	{0x47, 0xFD},
	{0x48, 0xFF},
	{0x49, 0x1F},
	{0x4A, 0xF7},
	{0x4B, 0xFD},
	{0x4C, 0xFF},
	{0x4D, 0x27},
	{0x4E, 0x5E},
	{0x4F, 0xBD},
	{0x50, 0xFF},
	{0x51, 0x00},
	{0x52, 0x11},
	{0x53, 0x92},
	{0x54, 0xC7},
	{0x55, 0x23},
	{0x56, 0x3A},
	{0x57, 0x31},
	{0x58, 0xFF},
	{0x59, 0x06},
	{0x5A, 0x56},
	{0x5B, 0xFD},
	{0x5C, 0xFF},
	{0x5D, 0x1F},
	{0x5E, 0xF7},
	{0x5F, 0xFD},
	{0x60, 0xFF},
	{0x61, 0x27},
	{0x62, 0x5E},
	{0x63, 0xBD},
	{0x64, 0xFF},
	{0x65, 0x00},
	{0x66, 0x11},
	{0x67, 0x92},
	{0x68, 0xC7},
	{0x69, 0x23},
	{0x6A, 0x3A},
	{0x6B, 0x31},
	{0x6C, 0xFF},
	{0x2D, 0x85}
};

#else
static BYTE es8374_reg_defaults[][2] = {
	{0x00, 0x3F},       //  Soft reset
	//msleep(50);            //must need some delay time
	{0x00, 0x03},       // un reset, to normal operation

	{0x01, 0xFF},	// 
	{0x6F, 0xA0},	// 
	{0x72, 0x41},	// 
	{0x09, 0x01},	// 
	{0x0C, 0x0B},	// 
	{0x0D, 0xDA},	// 
	{0x0E, 0xCC},	// 
	{0x0A, 0x3A},	// 
	{0x0B, 0x07},	// 
	{0x09, 0x41},	// 
	{0x06, 0x06},	// Internal DACLRCK divider[11:8]
	{0x07, 0x08},	// Internal DACLRCK divider[7:0]
	{0x0F, 0x9D},	// 
	{0x02, 0x08},	// 
	{0x36, 0x40},	// 
	{0x12, 0x30},	// 
	{0x13, 0x20},	// 
	{0x00, 0x80},	// 
	{0x15, 0x40},	// 
	{0x14, 0x8A},	// 
	{0x1A, 0xA0},	// Mono out / def:0x18
	{0x17, 0xA8},	// new
	{0x1B, 0x19},	// Mono out / def:0x00
	{0x1C, 0x90},	// 0x80 => 0x90
	{0x1D, 0x2B},
	{0x1F, 0x00},
	{0x1E, 0x00},	// 0xA0:SPK output, 0x00:disable

	{0x10, 0x2C},
	{0x11, 0x0C},

	{0x21, 0x14},
	{0x22, 0x03},
	{0x24, 0x00},
	{0x25, 0x00},
	{0x26, 0xCF},	// MIC ALC Control 0xCF(on) or 0x0F(off)
	{0x27, 0x04},
	{0x28, 0xA0},
	{0x29, 0x12},
	{0x2A, 0x06},
	{0x2B, 0x78},

	{0x38, 0x00},
	{0x37, 0x00},	// 0x08 => 0x00
	{0x6D, 0x60},

	{0x45, 0x06},
	{0x46, 0x56},
	{0x47, 0xFD},
	{0x48, 0xFF},
	{0x49, 0x1F},
	{0x4A, 0xF7},
	{0x4B, 0xFD},
	{0x4C, 0xFF},
	{0x4D, 0x27},
	{0x4E, 0x5E},
	{0x4F, 0xBD},
	{0x50, 0xFF},
	{0x51, 0x00},
	{0x52, 0x11},
	{0x53, 0x92},
	{0x54, 0xC7},
	{0x55, 0x23},
	{0x56, 0x3A},
	{0x57, 0x31},
	{0x58, 0xFF},
	{0x59, 0x06},
	{0x5A, 0x56},
	{0x5B, 0xFD},
	{0x5C, 0xFF},
	{0x5D, 0x1F},
	{0x5E, 0xF7},
	{0x5F, 0xFD},
	{0x60, 0xFF},
	{0x61, 0x27},
	{0x62, 0x5E},
	{0x63, 0xBD},
	{0x64, 0xFF},
	{0x65, 0x00},
	{0x66, 0x11},
	{0x67, 0x92},
	{0x68, 0xC7},
	{0x69, 0x23},
	{0x6A, 0x3A},
	{0x6B, 0x31},
	{0x6C, 0xFF},
	{0x2D, 0x85}
};
#endif

static UINT es8374_check(void)
{
	return I2C_CHECK(ES8374_I2C_WRITE);
}

static BYTE es8374_write_reg(BYTE reg, BYTE data)
{
	while(I2C_WRITE(ES8374_I2C_WRITE, 0, 0));
	if(I2C_WRITE(reg, 0, 0))	return DEF_FAIL;
	if(I2C_WRITE(data,1, 0))	return DEF_FAIL;
	return DEF_OK;
}

static BYTE es8374_read_reg(BYTE reg, BYTE *data)
{
	while(I2C_WRITE(ES8374_I2C_WRITE, 0, 0));
	if(I2C_WRITE(reg, 1, 1))	return DEF_FAIL;
	while(I2C_WRITE(ES8374_I2C_READ, 0, 0));
	*data = I2C_READ(1, 1);
	return DEF_OK;
}

void es8374_control(UINT mode, BYTE reg, BYTE *var)
{
	if(mode == 0)	// write
	{
		es8374_write_reg(reg, *var);
	}
	if(mode == 1)	// read
	{
		es8374_read_reg(reg, var);
	}
}
void es8374_w_control(BYTE reg, BYTE var)
{	
	es8374_write_reg(reg, var);
}

BYTE es8374_r_control(BYTE reg)
{
	BYTE var;
	es8374_read_reg(reg, &var);
	return var;
}

void es8374_volume_updown(BOOL updown)
{
	if(1)
	{
		if(updown)
		{
			es8374_info.volume++;
		}
		else
		{
			es8374_info.volume--;
		}
		es8374_write_reg( 0, 0x00);					// Page 0
		es8374_write_reg(65, es8374_info.volume);	// Left Analog Vol to HPL
		es8374_write_reg(66, es8374_info.volume);	// Right Analog Vol to HPR
	}
}

void es8374_init(void)
{
	int i, row;
	BYTE res;

//	printf("Start %s\r\n", __func__);

	if(es8374_check() == DEF_FAIL) 
	{
		printf("  >>ES8374 Not Connected...\r\n");
		goto err;
	}

	printf("  >>ES8374 Connected...\r\n");

	row = sizeof(es8374_reg_defaults) / sizeof(es8374_reg_defaults[0]);
	for (i=0; i<row; i++)
	{
		res = es8374_write_reg(es8374_reg_defaults[i][0], es8374_reg_defaults[i][1]);
		if (res != DEF_OK)
		{
			printf("  >>ES8374 reg set reg[0x%02X] write[0x%02X] fail!!\r\n", es8374_reg_defaults[i][0], es8374_reg_defaults[i][1]);
			break;
		}
		if (es8374_reg_defaults[i][0] == 0x00 || es8374_reg_defaults[i][0] == 0x36)
			WaitXms(50);
	}

err:
	return;
//	printf("End %s\r\n", __func__);
}
#endif
#endif
